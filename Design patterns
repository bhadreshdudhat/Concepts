Decorator Design Pattern
The decorator design pattern allows us to dynamically add functionality and behavior to an object without affecting the behavior of other existing objects within the same class. We use inheritance to extend the behavior of the class. This takes place at compile-time, and all the instances of that class get the extended behavior.

Decorator patterns allow a user to add new functionality to an existing object without altering its structure. So, there is no change to the original class.
The decorator design pattern is a structural pattern, which provides a wrapper to the existing class.
Decorator design pattern uses abstract classes or interfaces with the composition to implement the wrapper.
Decorator design patterns create decorator classes, which wrap the original class and supply additional functionality by keeping the class methodsâ€™ signature unchanged.
Decorator design patterns are most frequently used for applying single responsibility principles since we divide the functionality into classes with unique areas of concern.
The decorator design pattern is structurally almost like the chain of responsibility pattern.
Key points to remember 

Decorator design pattern is useful in providing runtime modification abilities and hence more flexible. Its easy to maintain and extend when the amount of choices are more.
The disadvantage of decorator design pattern is that it uses plenty of similar kind of objects (decorators)
Decorator pattern is used a lot in Java IO classes, like FileReader, BufferedReader, etc.

https://www.geeksforgeeks.org/decorator-design-pattern-in-java-with-example/

This is often a decent choice in the following cases where
--> When we wish to add, enhance or perhaps remove the behavior or state of objects
--> When we just want to modify the functionality of a single object of the class and leave others unchanged


----------------------------------------------

